{\rtf1\ansi\ansicpg1252\cocoartf2759
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\froman\fcharset0 Times-Bold;\f1\froman\fcharset0 Times-Roman;\f2\fmodern\fcharset0 Courier;
\f3\fmodern\fcharset0 Courier-Bold;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{decimal\}}{\leveltext\leveltemplateid1\'01\'00;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat6\levelspace360\levelindent0{\*\levelmarker \{decimal\}}{\leveltext\leveltemplateid101\'01\'00;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid2}
{\list\listtemplateid3\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat9\levelspace360\levelindent0{\*\levelmarker \{decimal\}}{\leveltext\leveltemplateid201\'01\'00;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid3}
{\list\listtemplateid4\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat15\levelspace360\levelindent0{\*\levelmarker \{decimal\}}{\leveltext\leveltemplateid301\'01\'00;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid4}
{\list\listtemplateid5\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat19\levelspace360\levelindent0{\*\levelmarker \{decimal\}}{\leveltext\leveltemplateid401\'01\'00;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid5}
{\list\listtemplateid6\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat24\levelspace360\levelindent0{\*\levelmarker \{decimal\}}{\leveltext\leveltemplateid501\'01\'00;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid6}
{\list\listtemplateid7\listhybrid{\listlevel\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat27\levelspace360\levelindent0{\*\levelmarker \{decimal\}}{\leveltext\leveltemplateid601\'01\'00;}{\levelnumbers\'01;}\fi-360\li720\lin720 }{\listname ;}\listid7}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}{\listoverride\listid3\listoverridecount0\ls3}{\listoverride\listid4\listoverridecount0\ls4}{\listoverride\listid5\listoverridecount0\ls5}{\listoverride\listid6\listoverridecount0\ls6}{\listoverride\listid7\listoverridecount0\ls7}}
\paperw11900\paperh16840\margl1440\margr1440\vieww33700\viewh21100\viewkind0
\deftab720
\pard\pardeftab720\sa280\partightenfactor0

\f0\b\fs28 \cf0 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 A. Creaci\'f3n de procesos y API POSIX\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sa240\partightenfactor0
\ls1\ilvl0
\f1\b0\fs24 \cf0 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	1	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 \'bfQu\'e9 devuelve 
\f2\fs26 fork()
\f1\fs24  en el 
\f0\b padre
\f1\b0  y qu\'e9 devuelve en el 
\f0\b hijo
\f1\b0 ? \'bfC\'f3mo lo usas para diferenciarlos en tu c\'f3digo?\
\ls1\ilvl0\kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	2	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 \'bfQu\'e9 ocurre si 
\f2\fs26 fork()
\f1\fs24  falla? \'bfC\'f3mo lo detectas y qu\'e9 deber\'edas hacer?\
\ls1\ilvl0\kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	3	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Explica la diferencia entre 
\f0\b PID
\f1\b0  y 
\f0\b PPID
\f1\b0 . \'bfQu\'e9 ver\'edas en 
\f2\fs26 getppid()
\f1\fs24  si el padre termina antes que el hijo?\
\ls1\ilvl0\kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	4	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 \'bfPor qu\'e9 pones 
\f2\fs26 _POSIX_C_SOURCE 200809L
\f1\fs24  al principio del archivo?\
\ls1\ilvl0\kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	5	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 \'bfQu\'e9 diferencias habr\'eda si en vez de procesos usaras 
\f0\b hilos
\f1\b0  (threads) para este ejercicio?\
\pard\pardeftab720\sa280\partightenfactor0

\f0\b\fs28 \cf0 B. Identidad del proceso y entorno\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sa240\partightenfactor0
\ls2\ilvl0
\f1\b0\fs24 \cf0 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	6	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 \'bfPara qu\'e9 sirve cada una de estas llamadas: 
\f2\fs26 getpid
\f1\fs24 , 
\f2\fs26 getppid
\f1\fs24 , 
\f2\fs26 getuid
\f1\fs24 , 
\f2\fs26 geteuid
\f1\fs24 , 
\f2\fs26 getgid
\f1\fs24 ? Pon un caso donde 
\f0\b UID \uc0\u8800  EUID
\f1\b0 .\
\ls2\ilvl0\kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	7	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 \'bfC\'f3mo hereda el 
\f0\b hijo
\f1\b0  el 
\f0\b entorno
\f1\b0  del padre? \'bfPor qu\'e9 
\f2\fs26 getenv("PATH")
\f1\fs24  muestra algo en ambos?\
\ls2\ilvl0\kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	8	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 \'bfQu\'e9 pasar\'eda si en el hijo haces 
\f2\fs26 setenv("PATH", "...")
\f1\fs24 ? \'bfSe ve en el padre? \'bfPor qu\'e9?\
\pard\pardeftab720\sa280\partightenfactor0

\f0\b\fs28 \cf0 C. Memoria: direcciones virtuales, COW y segmentos\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sa240\partightenfactor0
\ls3\ilvl0
\f1\b0\fs24 \cf0 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	9	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 En tu salida imprimes 
\f2\fs26 &g_var
\f1\fs24 , 
\f2\fs26 &l_var
\f1\fs24  y 
\f2\fs26 h_var
\f1\fs24 . \'bfPor qu\'e9 
\f0\b coinciden
\f1\b0  las 
\f0\b direcciones virtuales
\f1\b0  en padre e hijo tras 
\f2\fs26 fork()
\f1\fs24 ?\
\ls3\ilvl0\kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	10	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Explica 
\f0\b copy-on-write (COW)
\f1\b0  y en qu\'e9 momento se materializa (se copian) las p\'e1ginas de memoria.\
\ls3\ilvl0\kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	11	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 \'bfC\'f3mo demuestras en tu c\'f3digo que, aunque las direcciones virtuales coincidan, los 
\f0\b valores
\f1\b0  son 
\f0\b independientes
\f1\b0 tras modificar en el hijo?\
\ls3\ilvl0\kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	12	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Distingue los 
\f0\b segmentos
\f1\b0  de memoria donde viven: 
\f2\fs26 g_var
\f1\fs24  (global), 
\f2\fs26 l_var
\f1\fs24  (stack), 
\f2\fs26 *h_var
\f1\fs24  (heap).\
\ls3\ilvl0\kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	13	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 \'bfQu\'e9 cambiar\'eda si, en lugar de 
\f2\fs26 malloc
\f1\fs24 , usas una memoria 
\f0\b compartida
\f1\b0  (
\f2\fs26 mmap
\f1\fs24  con 
\f2\fs26 MAP_SHARED
\f1\fs24  o SHM) y la modificas en el hijo?\
\ls3\ilvl0\kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	14	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 \'bfLa 
\f0\b ASLR
\f1\b0  (aleatorizaci\'f3n de direcciones) afecta a que padre e hijo tengan las 
\f0\b mismas
\f1\b0  direcciones virtuales justo tras 
\f2\fs26 fork()
\f1\fs24 ? \'bfPor qu\'e9?\
\pard\pardeftab720\sa280\partightenfactor0

\f0\b\fs28 \cf0 D. Entrada/Salida y competencia por stdin\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sa240\partightenfactor0
\ls4\ilvl0
\f1\b0\fs24 \cf0 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	15	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 \'bfPor qu\'e9 ambos procesos compiten por 
\f2\fs26 stdin
\f1\fs24  al hacer 
\f2\fs26 scanf
\f1\fs24 ? \'bfQu\'e9 comportamiento pr\'e1ctico observas al ejecutar?\
\ls4\ilvl0\kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	16	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 \'bfPara qu\'e9 haces 
\f2\fs26 fflush(stdout)
\f1\fs24  antes del 
\f2\fs26 scanf
\f1\fs24 ? Explica 
\f0\b line buffering
\f1\b0  de 
\f2\fs26 stdout
\f1\fs24  en terminal.\
\ls4\ilvl0\kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	17	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 \'bfQu\'e9 ocurre si el usuario introduce 
\f0\b solo una palabra
\f1\b0 ? \'bfY si env\'eda 
\f0\b EOF
\f1\b0  (Ctrl-D)?\
\ls4\ilvl0\kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	18	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 \'bfC\'f3mo sincronizar\'edas el acceso a 
\f2\fs26 stdin
\f1\fs24  si quisieras evitar la competencia (sin usar hilos)?\
\pard\pardeftab720\sa280\partightenfactor0

\f0\b\fs28 \cf0 E. Ficheros y descriptores compartidos\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sa240\partightenfactor0
\ls5\ilvl0
\f1\b0\fs24 \cf0 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	19	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 \'bfPor qu\'e9 abres el fichero 
\f0\b antes
\f1\b0  de 
\f2\fs26 fork()
\f1\fs24 ? \'bfQu\'e9 se 
\f0\b hereda
\f1\b0  exactamente: el 
\f0\b descriptor
\f1\b0  o la 
\f0\b open file description
\f1\b0 (offset, flags)?\
\ls5\ilvl0\kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	20	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 \'bfC\'f3mo demostrar\'edas que 
\f0\b comparten offset
\f1\b0 ? (Pista: 
\f2\fs26 lseek(fd, 0, SEEK_CUR)
\f1\fs24  antes y despu\'e9s de escribir).\
\ls5\ilvl0\kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	21	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 \'bfTus escrituras con 
\f2\fs26 dprintf(fd, ...)
\f1\fs24  son at\'f3micas? \'bfQu\'e9 pasa si las l\'edneas son largas? \'bfCambiar\'eda algo usando 
\f2\fs26 O_APPEND
\f1\fs24 ?\
\ls5\ilvl0\kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	22	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 \'bfQu\'e9 pasar\'eda si en el hijo cierras con 
\f2\fs26 close(fd)
\f1\fs24  y el padre sigue escribiendo? \'bfY al rev\'e9s?\
\ls5\ilvl0\kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	23	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 \'bfPara qu\'e9 usar\'edas la bandera 
\f3\b\fs26 O_CLOEXEC
\f1\b0\fs24  al abrir archivos si luego fueses a llamar a 
\f2\fs26 exec()
\f1\fs24 ?\
\pard\pardeftab720\sa280\partightenfactor0

\f0\b\fs28 \cf0 F. Orden, sincronizaci\'f3n y finalizaci\'f3n\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sa240\partightenfactor0
\ls6\ilvl0
\f1\b0\fs24 \cf0 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	24	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 \'bfPor qu\'e9 ser\'eda \'fatil que el padre hiciera un 
\f2\fs26 waitpid(pid, &st, 0)
\f1\fs24 ? \'bfQu\'e9 problema evita respecto a 
\f0\b zombies
\f1\b0 ?\
\ls6\ilvl0\kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	25	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 \'bfEn tu dise\'f1o podr\'eda quedar un 
\f0\b proceso zombie
\f1\b0 ? \'bfEn qu\'e9 situaci\'f3n y c\'f3mo lo evitar\'edas?\
\ls6\ilvl0\kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	26	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 \'bfPor qu\'e9 en el 
\f0\b hijo
\f1\b0  usas 
\f2\fs26 _exit(0)
\f1\fs24  y no 
\f2\fs26 exit(0)
\f1\fs24 ? \'bfQu\'e9 riesgo hay con los 
\f0\b buffers de stdio
\f1\b0  tras 
\f2\fs26 fork()
\f1\fs24 ?\
\pard\pardeftab720\sa280\partightenfactor0

\f0\b\fs28 \cf0 G. Verificaci\'f3n y depuraci\'f3n\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sa240\partightenfactor0
\ls7\ilvl0
\f1\b0\fs24 \cf0 \kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	27	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 \'bfQu\'e9 comandos usar\'edas para observar la relaci\'f3n padre-hijo en tiempo real? (p. ej., 
\f2\fs26 ps -o pid,ppid,stat,cmd
\f1\fs24  | 
\f2\fs26 pstree
\f1\fs24  | 
\f2\fs26 strace -f
\f1\fs24 )\
\ls7\ilvl0\kerning1\expnd0\expndtw0 \outl0\strokewidth0 {\listtext	28	}\expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 \'bfC\'f3mo demostrar\'edas, con una \'fanica ejecuci\'f3n, que el padre 
\f0\b no ve
\f1\b0  las modificaciones de 
\f2\fs26 g_var
\f1\fs24 , 
\f2\fs26 l_var
\f1\fs24  y 
\f2\fs26 *h_var
\f1\fs24 que hizo el hijo (pista: re-imprimir en el padre 
\f0\b despu\'e9s
\f1\b0  de 
\f2\fs26 waitpid
\f1\fs24 )?\
}